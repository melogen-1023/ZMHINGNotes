## 内存

### 存储单元

#### 按字节编址

#### 按字编址

> 每个存储单元为1个字，字具体为多少位因计算机不同而变化

### 存储地址



### 相对地址与绝对地址





### 进程运行的基本原理

#### 从写程序到程序运行

编辑源代码，编译，链接，装入



#### 三种链接方式

**静态链接**

**装入时链接**

**进行时动态链接**



#### 三种装入方式

**绝对装入**

**可重定位装入（静态重定位）**

**动态运行时装入（动态重定位）**



### 内存管理

#### 内存空间的分配与回收



#### 内存保护

方法一：上下限寄存器



方法二：

采用**重定位寄存器（基址寄存器）**存放进程的起始物理地址，

**界地址寄存器（限长寄存器）**存放的是进程的最大逻辑地址，用于进行地址访问越界检查



#### 内存扩充

##### 交换技术



### 内存连续分配管理

#### 单一连续分配

#### 固定分区分配

#### 动态分区分配

在进程装入内存时，动态的创建分区

具体怎么分配见**动态分区分配算法**





#### 空闲分区的使用的两种数据结构：空闲分区表，空闲分区链



### 动态分区分配算法

#### 首次适应算法

![1574484477330](E:\docsify\docs\操作系统\images\1574484477330.png)

#### 最佳适应算法

![1574484401562](E:\docsify\docs\操作系统\images\1574484401562.png)

#### 最坏适应算法（最大适应算法）

![1574484555483](E:\docsify\docs\操作系统\images\1574484555483.png)

#### 邻近适应算法

![1574484801819](E:\docsify\docs\操作系统\images\1574484801819.png)



##### 内部碎片

进程所在的内存区域没有完全利用，有部分空闲的内存块叫内部碎片

#### 外部碎片

内存中某些空闲分区由于太小难以利用的叫外部碎片

> 可通过紧凑法解决外部碎片问题



### 内存非连续分配管理（离散分配）

#### 基本分页存储管理

##### 页框（页帧，内存块，物理块）， 页框号

将内存分成一个个，大小一样的区域，称为页框

##### 页面，页面号

将进程的逻辑地址空间分成和内存块一样大小的区域，称为页面

##### 如何实现地址转换

通过页内偏移量和页面对应的内存块在内存的起始地址之和求出物理地址

##### 页内偏移量

##### 如何计算页号，页内偏移量

十进制地址表示（也是考试内容）时如何计算

了解二进制地址表示时计算机是如何计算的

##### 页表

> 用于操作系统管理各个页面，记录了每个页面对应的内存块的编号

一个进程对应一个页表，进程的每一个页对应一个页表项，每个页表项由页号和块号组成

了解为什么页号在真正页表存储中是隐含的（也就是不用存储）（因为通过页表项的长度就可以确定是哪个页号）

#### 基本地址变换机构（用于实现逻辑地址到物理地址的转换的一套硬件结构）

掌握逻辑地址到物理地址的变换过程，计算过程



> 设页内偏移量占的位数为n,那么2^n 为页面大小（因为页内偏移量位数决定了偏移量的范围：0 - 2^n-1, 即最多偏移量为2^n-1,那么每个页面的长度为2^n个存储单元,即页面大小为2^n个存储单元）



### 具有快表的地址变换机构

快表是由一个速度更快的寄存器存储页面

慢表是内存里的页表

具有快表的地址变换机构可以改善频繁访问相同页面的效率，快表里存放的是最近访问的慢表里的页表项

每次地址变换都会优先查快表，如果没有找到对应的页表项，那么再查慢表

> 掌握具有快表的地址变换过程

### 多级页表



### 基本分段存储管理

#### 逻辑地址结构

段号+段内偏移量



#### 段表结构

| 段号 | 段长 | 段基址（段在内存的起始地址） |
| ---- | ---- | ---------------------------- |
| ...  | ...  | ...                          |



#### 段表寄存器

存放进程对应的段表始址和段表长度，并在进程访问数据时进行越界检查







### 分段，分页管理的对比

**分段可以实现数据的共享和保护**

**分页不会产生外部碎片**

为了集成两种优点，提出了下方的段页式管理



### 段页式存储管理

将进程按逻辑模块分段，再对每个段分页



##### 逻辑地址结构

段号 + 页号 + 页内偏移量



用户只需给出段号，段内偏移量，操作系统根据**段内偏移量**计算**页号**和**页内偏移量**



##### 段表结构

| 段号（隐式） | 页表长度 | 页表存放内存块号 |
| ------------ | -------- | ---------------- |
| ...          | ...      | ...              |

##### 页表结构

| 页号（隐式） | 内存块号 |
| ------------ | -------- |
| ...          | ...      |

## 虚拟内存

### 一次性

### 驻留性



### 虚拟存储技术

#### 时间局部性

#### 空间局部性



#### 虚拟内存的最大容量，实际容量

掌握如何计算



#### 虚拟内存的实现

##### 请求分页存储管理

在进程运行时发现缺少某个页面时会发生**缺页中断（内中断）**

**地址变换过程**

![1574588913518](E:\docsify\docs\操作系统\images\1574588913518.png)

##### 请求分段存储管理

##### 请求段页式存储管理

> 与基本的存储管理相比多出两种功能：请求调页（请求调段）， 页面置换（段置换）

##### 请求调页（请求调段）

将页（段）调入至内存

##### 页面置换（段置换）

将页（段）调出至外存



### 页面置换算法

#### 缺页率

用于度量各种置换算法的性能

**计算： 缺页次数/访问页面总次数**



#### 最佳置换算法

![1574589818495](E:\docsify\docs\操作系统\images\1574589818495.png)

> 需要知道未来会访问的页面，不可实现

#### 先进先出置换算法 (FIFO)

每次选择淘汰的页面是最早进入内存的页面

**Belady异常（分配的内存块变多，缺页次数却也变多）**

> 算法性能差

#### 最近最久未使用置换算法（LRU）

![1574594098399](E:\docsify\docs\操作系统\images\1574594098399.png)

#### 时钟置换算法（CLOCK，NRU，最近未用算法）



#### 改进型时钟算法