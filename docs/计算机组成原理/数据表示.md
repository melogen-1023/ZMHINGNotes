## 数据表示

### 原码



###  补码

可以将减法变为加法

#### 整数补码计算方法

$$
假设整数数据位长度为n \\
x > 0,[x]_{补} = 2^{n+1} + x \mod 2^{n+1}
\\
x< 0,[x]_{补} = 2^{n+1} - x \mod 2^{n+1}
$$



#### 小数补码计算方法

$$
假设小数数据位长度为n\\
x > 0, [x]_{补} = 2 + x \mod 2
\\
x < 0, [x]_{补} = 2 - x \mod 2
$$



#### 例

$$
假设字长为5位，数据位为4位\\

[+1101]_{补} = 100000 + 1101 \mod 100000 = 0,1101\\(最高位舍去，因为字长只有5位)
\\
[-1101]_{补} = 100000 - 1101 \mod 100000 = 1,0011
$$



#### 注

当数据为负数时，其实可以将原码的数据位进行取反，再在最低位加1，即可得到补码

**这样做的依据是：**
$$
[-1101]_{补} = 100000 - 1101 = 11111 - 1101 + 1\\
在11111-1101过程中，其实就是将1101每一位取反，然后再加1
$$










**补码与原码的转换是可逆的**



### 反码



### 移码

补码符号位取反就是移码

所以移码用来解决补码比大小的问题，移码比大小更直观



## 定点小数与浮点小数

#### 定点小数





#### 浮点小数





**科学计数法**
$$
N = m*r^{j}
\\
m为尾数，采用定点小数的小数点在数据位前表示法
\\
r为基数，一般为2
\\
j为阶数(二进制)\\
尾数和阶数都有正负，采用原码表示法
\\
例：0.0101001*2^{0,1101}\\
1.0100101*2^{1,1101}
$$


**浮点数的规格化**
$$
要求尾数数据位的最高位不能为0\\这样做是去除多余的0位，以最大化尾数有效位
\\
例:0.100000*2^{0,1101}
$$



##### IEEE标准



### 定点运算

#### 移位运算



##### 算术移位



##### 逻辑移位



#### 加减法运算

$$
[A]_{补} + [B]_{补} = [A+B]_{补}
\\
[A-B]_{补} = [A]_{补} + [-B]_{补}
$$



##### 溢出判断

**一位符号位判溢出**

如果参加操作的两个数符号相同，其结果的符号与原操作数的符号**不同**，即为溢出



##### 两位符号位判溢出



#### 乘法运算

* 乘法运算可用加法和移位实现，n=4,加4次，移4次
* 由乘数的末位决定被乘数是否与原**部分积**相加，然后部分积右移1位形成新的部分积，同时乘数右移1位（末位移丢），空出高位存放部分积的低位。
* **位积**（被乘数或0）只需要与部分积的高位相加（即不和存放在乘数寄存器中的部分积相加，即和部分积**向左对齐**）



#### 原码乘法



##### 一位乘递推公式



**原码乘法进行的是绝对值相乘，逻辑移位**





#### 原码除法

##### 恢复余数法

